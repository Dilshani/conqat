/*-------------------------------------------------------------------------+
|                                                                          |
| Copyright 2005-2011 The ConQAT Project                                   |
|                                                                          |
| Licensed under the Apache License, Version 2.0 (the "License");          |
| you may not use this file except in compliance with the License.         |
| You may obtain a copy of the License at                                  |
|                                                                          |
|    http://www.apache.org/licenses/LICENSE-2.0                            |
|                                                                          |
| Unless required by applicable law or agreed to in writing, software      |
| distributed under the License is distributed on an "AS IS" BASIS,        |
| WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. |
| See the License for the specific language governing permissions and      |
| limitations under the License.                                           |
+-------------------------------------------------------------------------*/
package org.conqat.engine.core.javadoc;

import java.lang.reflect.Field;
import java.util.Map;

import org.conqat.engine.core.core.AConQATAttribute;
import org.conqat.engine.core.core.AConQATFieldParameter;
import org.conqat.engine.core.core.AConQATKey;
import org.conqat.engine.core.core.AConQATParameter;
import org.conqat.engine.core.core.AConQATProcessor;

import com.sun.javadoc.AnnotationDesc;
import com.sun.javadoc.AnnotationDesc.ElementValuePair;
import com.sun.javadoc.ClassDoc;
import com.sun.javadoc.Doc;
import com.sun.javadoc.FieldDoc;
import com.sun.javadoc.MethodDoc;
import com.sun.javadoc.Parameter;
import com.sun.javadoc.Tag;
import com.sun.tools.doclets.internal.toolkit.taglets.Taglet;
import com.sun.tools.doclets.internal.toolkit.taglets.TagletOutput;
import com.sun.tools.doclets.internal.toolkit.taglets.TagletWriter;

/**
 * This taglet allows simplified, non-redundant Javadoc comments by copying the
 * descriptions provided for ConQAT annotations to the generated documentation.
 * 
 * Implementation notes: Javadoc comments are generated in two different ways:
 * the full comment for detailed descriptions and the so-called "first sentence"
 * of a comment that is used in the various overview tables generated by
 * Javadoc. As the ConQATDoc taglet is often used as the only content of
 * comment, we need to distinguish between these to modes to provide shortened
 * (first sentence) descriptions for the overview tables.
 * <p>
 * The official taglet API, defined by interface
 * {@link com.sun.tools.doclets.Taglet}, does not provide this distinction for
 * inline taglet. Hence, we use the new, still unofficial API, defined by
 * interface {@link Taglet}. However, the current implementation of Javadoc
 * already refers to the official API as "legacy" and it is to be expected that
 * the API used here will become the standard taglet API.
 * <p>
 * The problem of the unoffical API used here, is that the distinction between
 * normal and first-sentence mode is done via protected field of class
 * {@link TagletWriter}. To circumenvent this problem, we use an
 * reflection-based access to this field that subverts the default Java access
 * protection. Obviously, this is bound to break as soon as the implementation
 * of the API changes, e.g. if the field is removed. Determination of the
 * required field is carried on in a static initializer of this class. Hence,
 * problems will be detected automatically and logged. If something goes wrong
 * with this workaround, the taglet still works but always uses the normal,
 * non-abbreviated comments.
 * <p>
 * Creating a helper class in package with the same name does not work as
 * classes are loaded by different class loaders.
 * 
 * @author $Author: kinnen $
 * @version $Rev: 41751 $
 * @ConQAT.Rating GREEN Hash: B5714BE4FC972D5CC5C096963A9132C2
 */
public class ConQATTaglet implements Taglet {

	/** Annotation element. */
	private static final String ANNOTATION_ELEMENT_DEFAULT_VALUE = "defaultValue";

	/** Annotation element. */
	private static final String ANNOTATION_ELEMENT_NAME = "name";

	/** Annotation element. */
	private static final String ANNOTATION_ELEMENT_DESCRIPTION = "description";

	/**
	 * Name of the field in class {@link TagletWriter} that signals first
	 * sentence mode.
	 */
	private static final String FIRST_SENTENCE_FIELD_NAME = "isFirstSentence";

	/** Name of the taglet. */
	private static final String TAGLET_NAME = "ConQAT.Doc";

	/**
	 * Field in class {@link TagletWriter} that signals first sentence mode. If
	 * this is <code>null</code> something with the workaround explained above
	 * went wrong.
	 */
	private final static Field field = determineFirstSentenceField();

	/**
	 * Determine the field in class TageletWriter that signals the first
	 * sentence mode. If any problems occur, this returns <code>null</code> and
	 * writes warning to std.err.
	 */
	private static Field determineFirstSentenceField() {
		try {
			Field field = TagletWriter.class
					.getDeclaredField(FIRST_SENTENCE_FIELD_NAME);
			// as the field is protected, this is needed to subvert access
			// control.
			field.setAccessible(true);
			return field;
		} catch (SecurityException e) {
			System.err
					.println("Implementation of TageletWriter seems to be changed.");

		} catch (NoSuchFieldException e) {
			System.err
					.println("Implementation of TageletWriter seems to be changed.");
		}
		return null;
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public String getName() {
		return TAGLET_NAME;
	}

	/**
	 * Checks the type of the program element and determines comment
	 * accordingly.
	 */
	@Override
	public TagletOutput getTagletOutput(Tag tag, TagletWriter writer) {

		Doc doc = tag.holder();

		String text;
		if (doc instanceof MethodDoc) {
			text = methodDoc((MethodDoc) doc);
		} else if (doc instanceof ClassDoc) {
			text = classDoc((ClassDoc) doc);
		} else if (doc instanceof FieldDoc) {
			text = fieldDoc((FieldDoc) doc);
		} else {
			throw new IllegalStateException("Should not happen.");
		}

		if (isFirstSentence(writer)) {
			text = getFirstSentence(text);
		}

		TagletOutput result = writer.getOutputInstance();
		result.setOutput(text);
		return result;
	}

	/** Determine comment for a ConQAT.Doc tag at ConQAT parameter method. */
	private String methodDoc(MethodDoc methodDoc) {
		AnnotationDesc annotation = getAnnotation(methodDoc.annotations(),
				AConQATParameter.class);

		if (annotation == null) {
			return "Illegal use of ConQATDoc tag. Requires annotation "
					+ AConQATParameter.class.getSimpleName() + ".";
		}

		StringBuilder builder = new StringBuilder();

		builder.append(getValue(annotation, ANNOTATION_ELEMENT_DESCRIPTION));
		builder.append("<P><B>ConQAT Attributes:</B><UL>");
		for (Parameter parameter : methodDoc.parameters()) {
			AnnotationDesc paramAnnotation = getAnnotation(
					parameter.annotations(), AConQATAttribute.class);
			builder.append("<LI>");
			builder.append(getValue(paramAnnotation, ANNOTATION_ELEMENT_NAME));
			builder.append(": ");
			builder.append(getValue(paramAnnotation,
					ANNOTATION_ELEMENT_DESCRIPTION));
			String defaultValue = getValue(paramAnnotation,
					ANNOTATION_ELEMENT_DEFAULT_VALUE);
			if (defaultValue != null) {
				builder.append(" [" + defaultValue + "]");
			}
			builder.append("</LI>");
		}
		builder.append("</UL>");

		return builder.toString();
	}

	/** Determine comment for a ConQAT.Doc tag at ConQAT processor class. */
	private String classDoc(ClassDoc classDoc) {
		AnnotationDesc annotation = getAnnotation(classDoc.annotations(),
				AConQATProcessor.class);

		if (annotation == null) {
			return "Illegal use of ConQATDoc tag. Requires annotation "
					+ AConQATProcessor.class.getSimpleName() + ".";
		}

		return getValue(annotation, ANNOTATION_ELEMENT_DESCRIPTION);
	}

	/** Determine comment for a ConQAT.Doc tag at ConQAT key field. */
	private String fieldDoc(FieldDoc fieldDoc) {
		AnnotationDesc keyAnnotation = getAnnotation(fieldDoc.annotations(),
				AConQATKey.class);

		if (keyAnnotation != null) {
			return getValue(keyAnnotation, ANNOTATION_ELEMENT_DESCRIPTION);
		}

		AnnotationDesc fieldAnnotation = getAnnotation(fieldDoc.annotations(),
				AConQATFieldParameter.class);
		if (fieldAnnotation != null) {
			return getValue(fieldAnnotation, ANNOTATION_ELEMENT_DESCRIPTION);
		}

		return "Illegal use of ConQATDoc tag. Requires annotation "
				+ AConQATKey.class.getSimpleName() + " or "
				+ AConQATFieldParameter.class.getSimpleName() + ".";
	}

	/** Get the first sentence of a text. */
	private String getFirstSentence(String text) {
		int index = text.indexOf('.');
		if (index < 0) {
			return text;
		}
		return text.substring(0, index + 1);
	}

	/**
	 * Checks if the writer is in "first sentence mode". This is the
	 * implementation of the wild workaround explained in the class comment.
	 */
	private boolean isFirstSentence(TagletWriter writer) {

		// If field is null, something went wrong. We deny first sentence mode,
		// so comments will not be abbreviated.
		if (field == null) {
			System.err.println("Error determining first sentence state.");
			return false;
		}

		try {
			return (Boolean) field.get(writer);
		} catch (Exception e) {
			// Something went wrong
			System.err.println("Error determining first sentence state: "
					+ e.getMessage());
			return false;
		}
	}

	/**
	 * Get annotation of certain type.
	 * 
	 * @return the annotation or <code>null</code> if annotation was not found.
	 */
	private AnnotationDesc getAnnotation(AnnotationDesc[] annotations,
			Class<?> annotation) {
		for (AnnotationDesc element : annotations) {
			if (element.annotationType().qualifiedTypeName()
					.equals(annotation.getName())) {
				return element;
			}
		}
		return null;
	}

	/**
	 * Get annotation value.
	 * 
	 * @returns the value or <code>null</code> if key was not found.
	 */
	private String getValue(AnnotationDesc annotation, String key) {
		for (ElementValuePair pair : annotation.elementValues()) {
			if (pair.element().name().equals(key)) {
				// double call to value is correct as this returns the actual
				// value object.
				return pair.value().value().toString();
			}
		}
		return null;
	}

	/**
	 * {@inheritDoc}
	 * 
	 * @return <code>null</code>
	 */
	@Override
	public TagletOutput getTagletOutput(Doc doc, TagletWriter writer)
			throws IllegalArgumentException {
		return null;
	}

	/**
	 * {@inheritDoc}
	 * 
	 * @return <code>false</code>
	 */
	@Override
	public boolean inConstructor() {
		return false;
	}

	/**
	 * {@inheritDoc}
	 * 
	 * @return <code>true</code>
	 */
	@Override
	public boolean inField() {
		return true;
	}

	/**
	 * {@inheritDoc}
	 * 
	 * @return <code>true</code>
	 */
	@Override
	public boolean inMethod() {
		return true;
	}

	/**
	 * {@inheritDoc}
	 * 
	 * @return <code>false</code>
	 */
	@Override
	public boolean inOverview() {
		return false;
	}

	/**
	 * {@inheritDoc}
	 * 
	 * @return <code>false</code>
	 */
	@Override
	public boolean inPackage() {
		return false;
	}

	/**
	 * {@inheritDoc}
	 * 
	 * @return <code>true</code>
	 */
	@Override
	public boolean inType() {
		return true;
	}

	/**
	 * {@inheritDoc}
	 * 
	 * @return <code>true</code>
	 */
	@Override
	public boolean isInlineTag() {
		return true;
	}

	/**
	 * Register this Taglet.
	 * 
	 * @param tagletMap
	 *            the map to register this tag to.
	 */
	@SuppressWarnings({ "unchecked", "rawtypes" })
	public static void register(Map tagletMap) {
		ConQATTaglet taglet = new ConQATTaglet();
		tagletMap.put(taglet.getName(), taglet);
	}
}